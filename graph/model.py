"""
model.py

Represents the model of the graph and associated problems and solutions.
"""

import numpy as np
import json
import math
from . import EdgeSet
from graph.aspl import aspl

class Solution:
    """
    Represents a single solution to a Problem, which
    may not be the globally optimal solution.
    """
    def __init__(self, problem, edges, aspl, method, S_explored=None, known_optimal=False, id=None, termination_reason=None):
        """
        problem: The problem instance to which this solution belongs.
        edges: The set of edges that are included in this solution.
        aspl: The average shortest path length of the graph with these edges added.
        known_optimal: Whether this solution is known to be the global optimal solution.
        method: The name of the method used to find this solution.
        S_explored: The degree of the solution space explored.
        id: The unique identifier of this solution in the database. If None, it is assumed to be new.
        """
        self.problem = problem
        self.edges = EdgeSet(edges)
        self.S_explored = S_explored
        self.aspl = aspl
        self.method = method
        self.time = None
        self.trace = []
        self.iterations = None
        self.parameters = {}
        self.known_optimal = known_optimal
        self.id = None
        self.termination_reason = termination_reason
        self.problem.add_solution(self)

    def __repr__(self):
        return f"Solution generated by '{self.method}' with {len(self.edges)} edges and ASPL {self.aspl}"

    @property
    def pc_improvement(self):
        "Returns the percentage improvement in ASPL compared to the original graph."
        aspl_original = self.problem.aspl
        return (aspl_original - self.aspl) / aspl_original * 100.0

    @property
    def search_coverage(self):
        "Percentage of search space explored"
        N = self.problem.N
        return self.S_explored / N * 100.0
    
    @property
    def is_optimal(self):
        "Is this an optimal solution to the problem?"
        return self.known_optimal or self.problem.N == self.S_explored 
    
    def is_comparable(self, other):
        """
        Returns True if this solution's performance can be compared against other
        """
        return self.method == other.method and \
            self.parameters == other.parameters and \
            self.problem == other.problem

    
class Problem:
    """
    Represents a problem instance.
    """
    def __init__(self, G, S, k, solutions=None, id=None, method=None, method_parameters=None,
                 experiment_name=None, description=None):
        """
        G: The graph upon which the problem is expressed.
        S: The set of weighted edges that may be added
        k: The budget of edges that may be added
        soutions: Set of solutions found for this problem.
        id: Database ID of this problem. If none, it is assumed to be new.
        method: The name of the method used to generate the problem,
        method_parameters: The parameters used to generate the problem.
        experiment_name: Name of the experiment for which this problem was generated.
            used to group problems together.
        description: A description of the problem.
        """
        self.G = G
        self.S = EdgeSet(S)
        self.k = k
        self.id = id
        self.solutions = solutions or []
        self.method = method
        self.method_parameters = method_parameters
        self.experiment_name = experiment_name
        self.description = description

    def __repr__(self):
        return f"Problem Instance {str(self.id) + ' ' if self.id else ''}|S|={len(self.S)}, k={self.k} with {self.N} possible solutions"

    def add_solution(self, sln):
        self.solutions.append(sln)

    @property
    def N(self):
        "Returns the cardinality of the solution space - i.e. the number of possible solutions"
        return math.comb(len(self.S), self.k)
    
    @property
    def aspl(self):
        "Returns the ASPL for the graph upon which this problem is defined."
        if 'aspl' in self.G.graph:
            return self.G.graph['aspl']
        else:
            # This code is horrifc - everyhthing is called aspl!
            # TODO: fix
            G_aspl = aspl(self.G)
            self.G.graph['aspl'] = G_aspl
            return G_aspl

